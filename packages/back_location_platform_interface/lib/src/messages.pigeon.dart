// Autogenerated from Pigeon (v10.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

enum PigeonLocationAccuracy {
  powerSave,
  low,
  balanced,
  high,
  navigation,
}

class PigeonLocationData {
  PigeonLocationData({
    this.latitude,
    this.longitude,
    this.accuracy,
    this.altitude,
    this.bearing,
    this.bearingAccuracyDegrees,
    this.elapsedRealTimeNanos,
    this.elapsedRealTimeUncertaintyNanos,
    this.satellites,
    this.speed,
    this.speedAccuracy,
    this.time,
    this.verticalAccuracy,
    this.isMock,
  });

  double? latitude;

  double? longitude;

  double? accuracy;

  double? altitude;

  double? bearing;

  double? bearingAccuracyDegrees;

  double? elapsedRealTimeNanos;

  double? elapsedRealTimeUncertaintyNanos;

  int? satellites;

  double? speed;

  double? speedAccuracy;

  double? time;

  double? verticalAccuracy;

  bool? isMock;

  Object encode() {
    return <Object?>[
      latitude,
      longitude,
      accuracy,
      altitude,
      bearing,
      bearingAccuracyDegrees,
      elapsedRealTimeNanos,
      elapsedRealTimeUncertaintyNanos,
      satellites,
      speed,
      speedAccuracy,
      time,
      verticalAccuracy,
      isMock,
    ];
  }

  static PigeonLocationData decode(Object result) {
    result as List<Object?>;
    return PigeonLocationData(
      latitude: result[0] as double?,
      longitude: result[1] as double?,
      accuracy: result[2] as double?,
      altitude: result[3] as double?,
      bearing: result[4] as double?,
      bearingAccuracyDegrees: result[5] as double?,
      elapsedRealTimeNanos: result[6] as double?,
      elapsedRealTimeUncertaintyNanos: result[7] as double?,
      satellites: result[8] as int?,
      speed: result[9] as double?,
      speedAccuracy: result[10] as double?,
      time: result[11] as double?,
      verticalAccuracy: result[12] as double?,
      isMock: result[13] as bool?,
    );
  }
}

class PigeonNotificationSettings {
  PigeonNotificationSettings({
    this.channelName,
    this.channelDescription,
    this.title,
    this.iconName,
    this.subtitle,
    this.description,
    this.color,
    this.onTapBringToFront,
    this.setOngoing,
  });

  String? channelName;

  String? channelDescription;

  String? title;

  String? iconName;

  String? subtitle;

  String? description;

  String? color;

  bool? onTapBringToFront;

  bool? setOngoing;

  Object encode() {
    return <Object?>[
      channelName,
      channelDescription,
      title,
      iconName,
      subtitle,
      description,
      color,
      onTapBringToFront,
      setOngoing,
    ];
  }

  static PigeonNotificationSettings decode(Object result) {
    result as List<Object?>;
    return PigeonNotificationSettings(
      channelName: result[0] as String?,
      channelDescription: result[1] as String?,
      title: result[2] as String?,
      iconName: result[3] as String?,
      subtitle: result[4] as String?,
      description: result[5] as String?,
      color: result[6] as String?,
      onTapBringToFront: result[7] as bool?,
      setOngoing: result[8] as bool?,
    );
  }
}

class PigeonLocationSettings {
  PigeonLocationSettings({
    required this.askForGooglePlayServices,
    required this.useGooglePlayServices,
    required this.fallbackToGPS,
    required this.ignoreLastKnownPosition,
    this.expirationDuration,
    required this.fastestInterval,
    required this.interval,
    this.maxWaitTime,
    this.numUpdates,
    required this.accuracy,
    required this.smallestDisplacement,
    required this.waitForAccurateLocation,
    this.acceptableAccuracy,
  });

  bool askForGooglePlayServices;

  bool useGooglePlayServices;

  bool fallbackToGPS;

  bool ignoreLastKnownPosition;

  double? expirationDuration;

  double fastestInterval;

  double interval;

  double? maxWaitTime;

  int? numUpdates;

  PigeonLocationAccuracy accuracy;

  double smallestDisplacement;

  bool waitForAccurateLocation;

  double? acceptableAccuracy;

  Object encode() {
    return <Object?>[
      askForGooglePlayServices,
      useGooglePlayServices,
      fallbackToGPS,
      ignoreLastKnownPosition,
      expirationDuration,
      fastestInterval,
      interval,
      maxWaitTime,
      numUpdates,
      accuracy.index,
      smallestDisplacement,
      waitForAccurateLocation,
      acceptableAccuracy,
    ];
  }

  static PigeonLocationSettings decode(Object result) {
    result as List<Object?>;
    return PigeonLocationSettings(
      askForGooglePlayServices: result[0]! as bool,
      useGooglePlayServices: result[1]! as bool,
      fallbackToGPS: result[2]! as bool,
      ignoreLastKnownPosition: result[3]! as bool,
      expirationDuration: result[4] as double?,
      fastestInterval: result[5]! as double,
      interval: result[6]! as double,
      maxWaitTime: result[7] as double?,
      numUpdates: result[8] as int?,
      accuracy: PigeonLocationAccuracy.values[result[9]! as int],
      smallestDisplacement: result[10]! as double,
      waitForAccurateLocation: result[11]! as bool,
      acceptableAccuracy: result[12] as double?,
    );
  }
}

class _LocationHostApiCodec extends StandardMessageCodec {
  const _LocationHostApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is PigeonLocationData) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is PigeonLocationSettings) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is PigeonLocationSettings) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is PigeonNotificationSettings) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return PigeonLocationData.decode(readValue(buffer)!);
      case 129: 
        return PigeonLocationSettings.decode(readValue(buffer)!);
      case 130: 
        return PigeonLocationSettings.decode(readValue(buffer)!);
      case 131: 
        return PigeonNotificationSettings.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class LocationHostApi {
  /// Constructor for [LocationHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  LocationHostApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _LocationHostApiCodec();

  Future<PigeonLocationData> getLocation(PigeonLocationSettings? arg_settings) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.LocationHostApi.getLocation', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_settings]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as PigeonLocationData?)!;
    }
  }

  Future<bool> setLocationSettings(PigeonLocationSettings arg_settings) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.LocationHostApi.setLocationSettings', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_settings]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<bool> changeNotificationSettings(PigeonNotificationSettings arg_settings) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.LocationHostApi.changeNotificationSettings', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_settings]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<bool> setBackgroundActivated(bool arg_activated) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.LocationHostApi.setBackgroundActivated', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_activated]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }
}
